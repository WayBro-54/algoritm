################################
# partition
################################

# Базовым алгоритмом для быстрой сортировки является алгоритм partition, который разбивает набор элементов на две части относительно заданного предиката.
# По сути элементы массива просто меняются местами так, что левее некоторой точки в нем после этой операции лежат элементы, удовлетворяющие заданному предикату, а справа — не удовлетворяющие ему.
# Например, при сортировке можно использовать предикат «меньше опорного», что при оптимальном выборе опорного элемента может разбить массив на две примерно равные части.
#
# Напишите алгоритм partition в качестве первого шага для написания быстрой сортировки.
#
# Формат ввода
# В первой строке входного файла содержится число N — количество элементов массива (0 ≤ N ≤ 106).
# Во второй строке содержатся N целых чисел ai, разделенных пробелами (-109 ≤ ai ≤ 109).
# В третьей строке содержится опорный элемент x (-109 ≤ x ≤ 109).
# Заметьте, что x не обязательно встречается среди ai.
#
# Формат вывода
# Выведите результат работы вашего алгоритма при использовании предиката «меньше x»: в первой строке выведите число элементов массива, меньших x, а во второй — количество всех остальных.

def input_():
    # ввод данных  ипреобразование к целочисленному типу
    len_lst = int(input())
    lst = list(map(int, input().split()))
    opor = int(input())
    return len_lst, lst, opor


def partition(len_lst, lst, opor):
    ct = 0

    for i in lst:
        if i < opor:
          ct += 1
    return ct, (len_lst - ct)

def main():
    llst, lst, opor = input_()
    le, other = partition(llst, lst, opor)
    print(le)
    print(other)

# main()


# Слияние


def input_():
    # ввод данных  ипреобразование к целочисленному типу
    len_lst_1 = int(input())
    lst_1 = list(map(int, input().split()))
    len_lst_2 = int(input())
    lst_2 = list(map(int, input().split()))
    return len_lst_1, lst_1, len_lst_2, lst_2,

def merge(len1, lst1: list[int], len2, lst2: list[int]):
    res = []
    i, j = 0, 0
    while (i < len1) and (j < len2):
        if lst1[i] < lst2[j]:
            res.append(lst1[i])
            i += 1
        else:
            res.append(lst2[j])
            j += 1
    res += lst1[i:]
    res += lst2[j:]
    return res

def main():
    nlst1, lst1, nlst2, lst2 = input_()
    res = merge(nlst1, lst1, nlst2, lst2)
    print(''.join(res))
main()

##############################################
#           СОРТИРОВКА СЛИЯНИЕМ              #
##############################################


